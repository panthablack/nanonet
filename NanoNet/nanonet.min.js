export default class NanoNet{constructor(t){this.structure=t,this.layers=[],this.learningRate=.1,this.layers[0]={activations:[]};for(let e=0;e<t[0];e++)this.layers[0].activations.push(0);for(let e=1;e<t.length;e++){let i={activations:[],weights:[],biases:[]};for(let r=0;r<t[e];r++){i.activations.push(0),i.biases.push(0),i.weights.push([]);for(let s=0;s<t[e-1];s++)i.weights[r].push(NeuralNetwork.random(-1,1))}this.layers[e]=i}}get input(){return this.layers[0].activations}get output(){return this.layers[this.layers.length-1].activations}train(t){for(let e in t){let i=t[e],r=i[0],s=i[1];this.feedForward(r),this.propagateBackwards(s)}return this}feedForward(t){for(let e in t)this.layers[0].activations[e]=t[e];return this.feed()}feed(){for(let t=1;t<this.layers.length;t++){let e=this.getWeightedInputs(t),i=this.applyActivationFunction(e);this.layers[t].activations=i}return this}applyActivationFunction(t){let e=[];for(let i in t)e[i]=NeuralNetwork.sigmoid(t[i]);return e}applyActivationFunctionDerivative(t){let e=[];for(let i in t)e[i]=NeuralNetwork.sigmoidDerivative(t[i]);return e}propagateBackwards(t){let e=this.getOutputGradient(t),i=[];i[0]=this.getOutputDeltas(e);for(let t=1;t<this.layers.length-1;t++)i[t]=this.getDeltas(i[t-1],this.layers.length-1-t);return i.reverse(),this.updateWeightsAndBiases(i),this}updateWeightsAndBiases(t){for(let e=1;e<this.layers.length;e++){let i=this.layers[e],r=this.layers[e-1],s=t[e-1],a=i.weights,n=i.biases,l=r.activations,o=[];for(let t in s){o[t]=[];for(let e in l)o[t][e]=l[e]*s[t]}let u=[];for(let t in s)u[t]=s[t];for(let t in a){let e=a[t];for(let i in e)a[t][i]-=o[t][i]*this.learningRate}for(let t in n)n[t]-=u[t]*this.learningRate}return this}getOutputGradient(t){let e=[],i=this.output;for(let r in i)e[r]=i[r]-t[r];return e}getOutputDeltas(t){let e=[],i=this.getWeightedInputs(this.layers.length-1),r=this.applyActivationFunctionDerivative(i);for(let i in t)e[i]=t[i]*r[i];return e}getWeightedInputs(t){let e=this.layers[t],i=this.layers[t-1].activations,r=e.weights,s=e.biases,a=[];for(let t in s){let e=[];for(let s in i)e[s]=r[t][s]*i[s];let n=NeuralNetwork.sum(e);a[t]=n+s[t]}return a}getWeightedDeltas(t,e){let i=[];for(let r in t){let s=[];for(let i in e)s[i]=t[r][i]*e[i];let a=NeuralNetwork.sum(s);i[r]=a}return i}getDeltas(t,e){let i=this.layers[e+1],r=[],s=this.getWeightedInputs(e),a=this.applyActivationFunctionDerivative(s),n=this.transposeWeights(i.weights),l=this.getWeightedDeltas(n,t);for(let t in l)r[t]=l[t]*a[t];return r}transposeWeights(t){let e=[];for(let i in t){let r=t[i];for(let s in r)e[s]||(e[s]=[]),e[s][i]=t[i][s]}return e}static random(t=1,e=0){if("number"==typeof t&&"number"==typeof e){if(t!==e){let i=t<e?t:e,r=t<e?e:t;return Math.random()*(r-i)+i}throw"Range must be non-zero."}throw"Range min and max arguments must be valid numbers."}static sigmoid(t){if("number"==typeof t){let e=Math.exp(t),i=e/(1+e);return i<0?0:i>1?1:Number.isNaN(i)?.5:i}throw"Argument must be a number."}static sigmoidDerivative(t){if("number"==typeof t){let e=NeuralNetwork.sigmoid(t);return e*(1-e)}throw"Argument must be a number."}static sum(t){if(Array.isArray(t)&&t.length){let e=0;for(let i=0;i<t.length;i++){let r=t[i];if("number"!=typeof r||Number.isNaN(r))throw"Sum function can only sum numbers.";e+=r}return e}throw"Sum function can only accept arrays as arguments."}halt(t=null){throw t&&console.log(t),"halted"}}